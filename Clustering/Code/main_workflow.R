library(FactoMineR)
library(vcfR)
library(Rsamtools)
library(parallel)

source("main_utils.R")

############################### 
# Step 1: Compute 42 features #
###############################

## A. Find recurrent mutations using BCFTools using the VCF files as input ##

    #' Generate command line code for submitting a job to HPC that: 
    #'  - uses BCFTools to extract for each VCF file the mutations found in at least two VCF files and save these in a new VCF file. 
    #'  - uses awk to summarize the generated 'sites.txt' with all mutations found at least twice into a summary file.
    #' @param vcf_files: filepath including names of the vcf files 
    #' @param jobname: name of the job to sent to HPC
    #' @param clock_limit: time limit of job to sent to HCPC
    #' @param dataDir: directory to store results 
    #' @param rec_mut_file_folder: folder to store results
    #' @param scriptsDir: diretory to store script generate by funtion
    writeGetRecMutCommands2file <- function(vcf_files, jobname, clock_limit, dataDir, rec_mut_file_folder, scriptsDir)
    {
      bcftools_command <- paste("bcftools isec -f .,PASS -c none ", " -p ", dataDir, rec_mut_file_folder, " -n+2 ", paste(vcf_files, " ", collapse=""), "\n\n", sep="")
      awk_command <- paste("awk -F'\\t' -v fld=5 'BEGIN{print \"#CHROM\"\"\\t\"\"POS\"\"\\t\"\"REF\"\"\\t\"\"ALT\"\"\\t\"\"Count\"\"\\t\"\"lineNum\"}{print $1\"\\t\"$2\"\\t\"$3\"\\t\"$4\"\\t\"\"rec_count=\"gsub(/1/,\"\",$fld) \"\\t\" NR}' ", dataDir, rec_mut_file_folder, "/sites.txt > ", dataDir, rec_mut_file_folder, "/summary_", jobname, ".txt\n\n", sep="")
      job_command <- paste("#!/bin/bash\n# @ job_name = ", jobname, "\n# @ initialdir = .\n# @ output = ", jobname, "_%j.out\n# @ error = ", jobname, "_%j.err\n# @ wall_clock_limit= ", clock_limit, "\n# @ class = lowprio\n# @ cpus_per_task = 2\n",sep="")
      
      cat(job_command, file = paste(scriptsDir,jobname,".sh",sep=""))
      cat("module load gcc/4.9.3-gold\n\n", file = paste(scriptsDir,jobname,".sh",sep=""), append = TRUE)
      cat("module load xz/5.2.2\n\n", file = paste(scriptsDir,jobname,".sh",sep=""), append = TRUE)
      cat("module load BCFTOOLS/1.5\n\n", file = paste(scriptsDir,jobname,".sh",sep=""), append = TRUE)
      cat("date +\"%T\"\n\n", file = paste(scriptsDir,jobname,".sh",sep=""), append = TRUE)
      
      cat(bcftools_command, file = paste(scriptsDir,jobname, ".sh",sep=""), append = TRUE)
      cat(awk_command, file = paste(scriptsDir,jobname,".sh",sep=""), append = TRUE)
      cat("date +\"%T\"", file = paste(scriptsDir,jobname,".sh",sep=""), append = TRUE)
    }
    
    #' Read the file generated by BCFtools to connect original VCF to recurrent VCF as the VCF files with the recurrent mutations are automatically renamed by BCFTools
    #' @param dataDir: directory where the results of BCFtools are stored
    #' @param rec_mut_file_folder: folder where the results of BCFtools are stored
    #' @param mut_type: SSM or SIM
    #' @return return file linking the original VCF file to the VCF file with the recurrent SSMs or SIMs
    readMapping <- function(dataDir, rec_mut_file_folder, mut_type)
    {
      readme_file <- read.table(file = paste(dataDir, "/", rec_mut_file_folder, "/README.txt",sep=""), header=FALSE,sep = "\t", stringsAsFactors = FALSE, fill=TRUE)
      startingRow <- grep("Using the following file names:",readme_file[,1]) + 1
      
      mapping_vcfs <- readme_file[c(startingRow:nrow(readme_file)),c(1,3)]
      colnames(mapping_vcfs) <- c(paste("loc_recurrent_", mut_type, "_vcf",sep=""), paste("loc_all_", mut_type, "_vcf", sep=""))
      
      return(mapping_vcfs)
    }
    
    #' Parse the filename of the VCF file to obtain the tumor_wgs_aliquot_id
    #' @param mapping_vcfs: mapping of the original VCF file to the VCF file with the recurrent SSMs or SIMs
    #' @return file with the mapping between the sample ID and the original VCF file and the VCF file with recurrent SSMs or SIMs
    getAliquotIDFromFilename <- function(mapping_vcfs)
    {
      mapping_vcfs[,"tumor_wgs_aliquot_id"] <- unlist(lapply(1:nrow(mapping_vcfs), function(x) {
        
        split_dir <- unlist(strsplit(x = mapping_vcfs[x,2], split="/"))
        aliquot_id_filename <- unlist(strsplit(x = split_dir[length(split_dir)], split="\\."))[1]
      }))
      
       return(mapping_vcfs)
    }
    
    #' Construct mapping file linking original VCF file to recurrent VCF file
    #' @param dataDir: directory of the results of the BCFtools
    #' @param rec_sim_file_folder: folder with the results of the BCFtools for SIMs
    #' @param rec_ssm_file_folder: folder with the results of the BCFtools for SSMs
    #' @param aliquot2otherIDs: mapping of the tumor_wgs_aliquot_id to other identifiers needed to link to metadata
    #' @return file with the mapping between the sample ID, the original VCF file with SSMs, the original VCF file with SIMs, the VCF file with recurrent SSMs and the VCF file with the recurrent SIMs 
    constructSampleInfoFile <- function(dataDir, rec_sim_file_folder, rec_ssm_file_folder, aliquot2otherIDs)
    {
      mapping_sim_vcfs <- readMapping(dataDir, rec_sim_file_folder, "sim")
      mapping_ssm_vcfs <- readMapping(dataDir, rec_ssm_file_folder, "ssm")
      
      mapping_sim_vcfs <- getAliquotIDFromFilename(mapping_sim_vcfs)
      mapping_ssm_vcfs <- getAliquotIDFromFilename(mapping_ssm_vcfs)
      
      sample_info <- merge(mapping_sim_vcfs, mapping_ssm_vcfs, by="tumor_wgs_aliquot_id", sort=FALSE)
      sample_info <- merge(aliquot2otherIDs, sample_info, by="tumor_wgs_aliquot_id", all.y=TRUE, sort=FALSE)

      return(sample_info)
    }

## B. Compute the 42 features in absolute terms and in terms of percentages (when applicable)  ##

  #' Get the 42 features in absolute terms and in terms of percentages (when applicable)   
  #' @param sample_info_file: file with the mapping between the sample ID, the original VCF file with SSMs, the original VCF file with SIMs, the VCF file with recurrent SSMs and the VCF file with the recurrent SIMs 
  #' @param vcfIsFiltered: boolean to indicate whether or not the VCF file has been filtered based on the FILTER column
  #' @param recVcfIsFiltered: boolean to indicate whether or not the VCF file with the recurrent mutations has been filtered based on the FILTER column
  #' @param file_fastaGenome: location of the file with the genome sequence (GRCh37/h19)
  #' @param num_cores: number of cores to use in mclapply
  #' @return data.frame with the statistics per sample
  getStatistics <- function(sample_info_file,vcfIsFiltered,recVcfIsFiltered,file_fastaGenome, num_cores)
  {
    options(scipen=999)
    
    sample_info <- read.table(file = sample_info_file, header=TRUE, sep = "\t", stringsAsFactors = FALSE)
    
    stats_samples <- do.call(rbind, mclapply(1:nrow(sample_info), function(x)
    {
      # read in VCF file with all SSMs, remove those in the mitochondrion
      ssms_df <- vcf2df(sample_info[x,"loc_all_ssm_vcf"],vcfIsFiltered)
      ssms_df <- ssms_df[which(!(ssms_df$CHROM %in% c("MT", "M"))),]
      
      # read in VCF file with all SIMs , remove those in the mitochondrion
      sims_df <- vcf2df(sample_info[x,"loc_all_sim_vcf"],vcfIsFiltered)
      sims_df <- sims_df[which(!(sims_df$CHROM %in% c("MT", "M"))),]
      
      # read in VCF file with recurrent SSMs, remove those in the mitochondrion 
      recurrent_ssms_df <- vcf2df(sample_info[x,"loc_recurrent_ssm_vcf"],recVcfIsFiltered)
      recurrent_ssms_df <- recurrent_ssms_df[which(!(recurrent_ssms_df$CHROM %in% c("MT", "M"))),]
      
      # read in VCF file with recurrent SIMs, remove those in the mitochondrion 
      recurrent_sims_df <- vcf2df(sample_info[x,"loc_recurrent_sim_vcf"],recVcfIsFiltered)
      recurrent_sims_df <- recurrent_sims_df[which(!(recurrent_sims_df$CHROM %in% c("MT", "M"))),]
      
      sample_id <- sample_info[x,"sample_id"]
     
      # get the statistics for the current sample 
      stats_sample <- processSample(sample_id, ssms_df, sims_df,recurrent_ssms_df,recurrent_sims_df, file_fastaGenome)
  
      return(stats_sample)
      
    }, mc.cores=num_cores))
    
    
    return(stats_samples)
  }

  #' compute general and recurrent features for the sample
  #' @param sample_id: identifier of the sample
  #' @param ssms_df: data.frame with the SSMs of the sample
  #' @param sims_df: data.frame with the SIMs of the sample
  #' @param recurrent_ssms_df: data.frame with the recurrent SSMs of the sample
  #' @param recurrent_sims_df: data.frame with the recurrent SIMs of the sample
  #' @param file_fastaGenome: location of the file with the genome sequence (GRCh37/h19)
  #' @return all the statistics for the sample
  processSample <- function(sample_id, ssms_df, sims_df, recurrent_ssms_df,recurrent_sims_df, file_fastaGenome)
  {
    print("start processSample")
    
    all_measures <- c("sample_id", "num_ssms", "num_sims", "num_del", "num_ins", "num_del_ins", "perc_of_mut_sims", 
                      "num_CA", "num_CG", "num_CT", "num_TA", "num_TC", "num_TG", "perc_CA", "perc_CG", "perc_CT", "perc_TA", "perc_TC", "perc_TG", 
                      "num_1bp_del_A_T","num_1bp_del_C_G","num_1bp_ins_A_T","num_1bp_ins_C_G","perc_1bp_del_A_T","perc_1bp_del_C_G","perc_1bp_ins_A_T","perc_1bp_ins_C_G",
                      "num_polyL_1_del_A_T","num_polyL_2_del_A_T", "num_polyL_3_del_A_T", "num_polyL_4_del_A_T","num_polyL_5_del_A_T","num_polyL_6_del_A_T", "num_polyL_7_del_A_T","num_polyL_8_del_A_T","num_polyL_9_del_A_T", "num_polyL_10_del_A_T",  
                      "num_polyL_1_del_C_G","num_polyL_2_del_C_G", "num_polyL_3_del_C_G", "num_polyL_4_del_C_G","num_polyL_5_del_C_G","num_polyL_6_del_C_G", "num_polyL_7_del_C_G","num_polyL_8_del_C_G","num_polyL_9_del_C_G", "num_polyL_10_del_C_G",  
                      "num_polyL_0_ins_A_T","num_polyL_1_ins_A_T","num_polyL_2_ins_A_T", "num_polyL_3_ins_A_T", "num_polyL_4_ins_A_T","num_polyL_5_ins_A_T","num_polyL_6_ins_A_T", "num_polyL_7_ins_A_T","num_polyL_8_ins_A_T","num_polyL_9_ins_A_T", "num_polyL_10_ins_A_T",  
                      "num_polyL_0_ins_C_G","num_polyL_1_ins_C_G","num_polyL_2_ins_C_G", "num_polyL_3_ins_C_G", "num_polyL_4_ins_C_G","num_polyL_5_ins_C_G","num_polyL_6_ins_C_G", "num_polyL_7_ins_C_G","num_polyL_8_ins_C_G","num_polyL_9_ins_C_G", "num_polyL_10_ins_C_G",  
                      "num_noPoly_del_A_T","num_shortPoly_del_A_T","num_midSizePoly_del_A_T", "num_longPoly_del_A_T", 
                      "num_noPoly_del_C_G","num_shortPoly_del_C_G","num_midSizePoly_del_C_G", "num_longPoly_del_C_G",
                      "num_noPoly_ins_A_T","num_shortPoly_ins_A_T","num_midSizePoly_ins_A_T", "num_longPoly_ins_A_T",
                      "num_noPoly_ins_C_G","num_shortPoly_ins_C_G","num_midSizePoly_ins_C_G", "num_longPoly_ins_C_G",
                      "perc_noPoly_del_A_T","perc_shortPoly_del_A_T","perc_midSizePoly_del_A_T", "perc_longPoly_del_A_T", 
                      "perc_noPoly_del_C_G","perc_shortPoly_del_C_G","perc_midSizePoly_del_C_G", "perc_longPoly_del_C_G",
                      "perc_noPoly_ins_A_T","perc_shortPoly_ins_A_T","perc_midSizePoly_ins_A_T", "perc_longPoly_ins_A_T",
                      "perc_noPoly_ins_C_G","perc_shortPoly_ins_C_G","perc_midSizePoly_ins_C_G", "perc_longPoly_ins_C_G",
                      "num_rec_ssms", "perc_rec_ssms", "num_rec_sims","perc_rec_sims", "perc_of_rec_mut_sim", 
                      "num_rec_CA", "num_rec_CG", "num_rec_CT", "num_rec_TA", "num_rec_TC", "num_rec_TG", "perc_rec_CA", "perc_rec_CG", "perc_rec_CT", "perc_rec_TA", "perc_rec_TC", "perc_rec_TG",
                      "num_rec_1bp_del_A_T","num_rec_1bp_del_C_G","num_rec_1bp_ins_A_T","num_rec_1bp_ins_C_G","perc_rec_1bp_del_A_T","perc_rec_1bp_del_C_G","perc_rec_1bp_ins_A_T","perc_rec_1bp_ins_C_G")
    
    stats_sample_complete <- as.data.frame(matrix(data=0, nrow=1, ncol=length(all_measures)))
    colnames(stats_sample_complete) <- all_measures
    
    # get statistics for SSMs
    if(nrow(ssms_df) > 0){
      ssm_stats_sample <- getStatsSSMs(ssms_df,recurrent_ssms_df)
      stats_sample_complete[,colnames(ssm_stats_sample)] <- ssm_stats_sample
    }
    
    # get statistics for SIMs
    if(nrow(sims_df) > 0){
      sim_stats_sample <- getStatsSIMs(sims_df,recurrent_sims_df,file_fastaGenome)
      stats_sample_complete[,colnames(sim_stats_sample)] <- sim_stats_sample
    }
    
    # add percentage of total set of mutations of type SIM
    total_num_mut <- stats_sample_complete$num_ssms + stats_sample_complete$num_sims
    
    if(total_num_mut > 0)
      stats_sample_complete[,"perc_of_mut_sims"] <- (stats_sample_complete$num_sims*100)/total_num_mut
    else
      stats_sample_complete[,"perc_of_mut_sims"] <- 0
    
    # add percentage of recurrent mutations of type SIM
    total_rec_mut <- stats_sample_complete$num_rec_ssms + stats_sample_complete$num_rec_sims
    
    if(total_rec_mut > 0)
      stats_sample_complete[,"perc_of_rec_mut_sim"] <- (stats_sample_complete$num_rec_sims*100)/total_rec_mut
    else
      stats_sample_complete[,"perc_of_rec_mut_sim"] <- 0
    
    stats_sample_complete[,"sample_id"] <- sample_id
    
    print("end processSample")
    
    return(stats_sample_complete)
  }
  
  #' Compute general and recurrent statistics related to SSMs
  #' @param ssms_df: data.frame with the SSMs of the sample
  #' @param recurrent_ssms_df: data.frame with the recurrent SSMs of the sample
  #' @return data.frame with the statistics related to SSMs
  getStatsSSMs <- function(ssms_df,recurrent_ssms_df)
  {
    print("start getStatsSSMs")
    
    ssm_measures <- c("num_ssms", 
                      "num_CA", "num_CG", "num_CT", "num_TA", "num_TC", "num_TG", "perc_CA", "perc_CG", "perc_CT", "perc_TA", "perc_TC", "perc_TG", 
                      "num_rec_ssms", "perc_rec_ssms", 
                      "num_rec_CA", "num_rec_CG", "num_rec_CT", "num_rec_TA", "num_rec_TC", "num_rec_TG", "perc_rec_CA", "perc_rec_CG", "perc_rec_CT", "perc_rec_TA", "perc_rec_TC", "perc_rec_TG")
    
    ssm_stats_sample <- as.data.frame(matrix(data=0, nrow=1, ncol=length(ssm_measures)))
    colnames(ssm_stats_sample) <- ssm_measures
    
    # get total number of SSMs
    num_ssms<- nrow(ssms_df)
    
    ssm_stats_sample[,"num_ssms"] <- num_ssms
    
    # get number of SSMs per subtype C>A,C>G,C>T,T>A,T>C,T>G
    num_ssms_per_type <- countNumSSMsperType(ssms_df)
    colnames(num_ssms_per_type) <- paste("num_", sub(">", "", colnames(num_ssms_per_type)), sep="")
    
    ssm_stats_sample[,colnames(num_ssms_per_type)] <- num_ssms_per_type
    
    # compute percentage of SSMs per subtype C>A,C>G,C>T,T>A,T>C,T>G
    perc_ssms_per_type <- (num_ssms_per_type*100)/num_ssms
    colnames(perc_ssms_per_type) <- sub("num", "perc", colnames(perc_ssms_per_type))
    
    ssm_stats_sample[,colnames(perc_ssms_per_type)] <- perc_ssms_per_type
    
    # get statistics for recurrent SSMs
    if(!is.null(recurrent_ssms_df)){
      if(nrow(recurrent_ssms_df) > 0)
      {
        ssm_rec_stats <- getRecStatsSSMs(ssm_stats_sample,recurrent_ssms_df)
        ssm_stats_sample[,colnames(ssm_rec_stats)] <- ssm_rec_stats
      }
    }
    
    print("end getStatsSSMs")
    
    return(ssm_stats_sample)
  }
  
  #' Count the number of SSMs per subtype
  #' @param ssms_df: data.frame with the SSMs of the sample
  #' @return counts per SSM subtype
  countNumSSMsperType <- function(ssms_df)
  {
    ref2alt <- paste(ssms_df$REF,ssms_df$ALT, sep=">")
    
    ref2alt <- sub("G>A","C>T", ref2alt)
    ref2alt <- sub("G>C","C>G", ref2alt)
    ref2alt <- sub("G>T","C>A", ref2alt)
    ref2alt <- sub("A>C","T>G", ref2alt)
    ref2alt <- sub("A>G","T>C", ref2alt)
    ref2alt <- sub("A>T","T>A", ref2alt)
    
    ref2alt <- ref2alt[which(ref2alt %in% c("C>A", "C>G", "C>T", "T>A", "T>C", "T>G"))]
    
    num_ssms_per_type <- t(as.matrix(table(ref2alt)))
    
    return(num_ssms_per_type)
  }
  
  #' Compute the statistics for the recurrent SSMs
  #' @param stats_general: general statistics of the sample
  #' @param recurrent_ssms_df: data.frame with the recurrent SSMs of the sample
  #' @return data.frame with the statistics for the recurrent SSMs
  getRecStatsSSMs <- function(stats_general,recurrent_ssms_df)
  {
    print("start getRecStatsSSMs")
    
    num_ssms <- stats_general$num_ssms
    num_ssms_per_type <- stats_general[, c("num_CA", "num_CG", "num_CT", "num_TA", "num_TC", "num_TG")]
    
    ssm_rec_measures <- c("num_rec_ssms", "perc_rec_ssms", 
                          "num_rec_CA", "num_rec_CG", "num_rec_CT", "num_rec_TA", "num_rec_TC", "num_rec_TG", "perc_rec_CA", "perc_rec_CG", "perc_rec_CT", "perc_rec_TA", "perc_rec_TC", "perc_rec_TG")
    
    ssm_rec_stats_sample <- as.data.frame(matrix(data=0, nrow=1, ncol=length(ssm_rec_measures)))
    colnames(ssm_rec_stats_sample) <- ssm_rec_measures
    
    # get number and percentage of recurrent SSMs
    num_rec_ssms <- nrow(recurrent_ssms_df)
    perc_rec_ssms <- (num_rec_ssms*100)/num_ssms
    
    ssm_rec_stats_sample[,"num_rec_ssms"] <- num_rec_ssms
    ssm_rec_stats_sample[,"perc_rec_ssms"] <- perc_rec_ssms
    
    if(num_rec_ssms > 0)
    {
      num_rec_ssms_per_type <- countNumSSMsperType(recurrent_ssms_df)
      colnames(num_rec_ssms_per_type) <- paste("num_rec_", sub(">", "", colnames(num_rec_ssms_per_type)), sep="")
      
      perc_rec_ssms_per_type <- (num_rec_ssms_per_type*100)/num_ssms_per_type[,sub(pattern = "rec_", replacement = "",x = colnames(num_rec_ssms_per_type))]
      colnames(perc_rec_ssms_per_type) <- sub("num", "perc", colnames(num_rec_ssms_per_type))
      
      ssm_rec_stats_sample[,colnames(num_rec_ssms_per_type)] <- num_rec_ssms_per_type
      ssm_rec_stats_sample[,colnames(perc_rec_ssms_per_type)] <- perc_rec_ssms_per_type
    }
    
    print("end getStatsSSMs")
    
    return(ssm_rec_stats_sample)
  }
  
  #' Compute general and recurrent statistics related to SIMs
  #' @param sims_df: data.frame with the SIMs of the sample
  #' @param recurrent_sims_df: data.frame with the recurrent SIMs of the sample
  #' @return data.frame with the statistics related to SIMs
  getStatsSIMs <- function(sims_df,recurrent_sims_df,file_fastaGenome)
  {
    sim_measures <- c("num_sims", "num_del", "num_ins", "num_del_ins",
                      "num_1bp_del_A_T","num_1bp_del_C_G","num_1bp_ins_A_T","num_1bp_ins_C_G","perc_1bp_del_A_T","perc_1bp_del_C_G","perc_1bp_ins_A_T","perc_1bp_ins_C_G",
                      "num_polyL_1_del_A_T","num_polyL_2_del_A_T", "num_polyL_3_del_A_T", "num_polyL_4_del_A_T","num_polyL_5_del_A_T","num_polyL_6_del_A_T", "num_polyL_7_del_A_T","num_polyL_8_del_A_T","num_polyL_9_del_A_T", "num_polyL_10_del_A_T",  
                      "num_polyL_1_del_C_G","num_polyL_2_del_C_G", "num_polyL_3_del_C_G", "num_polyL_4_del_C_G","num_polyL_5_del_C_G","num_polyL_6_del_C_G", "num_polyL_7_del_C_G","num_polyL_8_del_C_G","num_polyL_9_del_C_G", "num_polyL_10_del_C_G",  
                      "num_polyL_0_ins_A_T","num_polyL_1_ins_A_T","num_polyL_2_ins_A_T", "num_polyL_3_ins_A_T", "num_polyL_4_ins_A_T","num_polyL_5_ins_A_T","num_polyL_6_ins_A_T", "num_polyL_7_ins_A_T","num_polyL_8_ins_A_T","num_polyL_9_ins_A_T", "num_polyL_10_ins_A_T",  
                      "num_polyL_0_ins_C_G","num_polyL_1_ins_C_G","num_polyL_2_ins_C_G", "num_polyL_3_ins_C_G", "num_polyL_4_ins_C_G","num_polyL_5_ins_C_G","num_polyL_6_ins_C_G", "num_polyL_7_ins_C_G","num_polyL_8_ins_C_G","num_polyL_9_ins_C_G", "num_polyL_10_ins_C_G",  
                      "num_noPoly_del_A_T","num_shortPoly_del_A_T","num_midSizePoly_del_A_T", "num_longPoly_del_A_T", 
                      "num_noPoly_del_C_G","num_shortPoly_del_C_G","num_midSizePoly_del_C_G", "num_longPoly_del_C_G",
                      "num_noPoly_ins_A_T","num_shortPoly_ins_A_T","num_midSizePoly_ins_A_T", "num_longPoly_ins_A_T",
                      "num_noPoly_ins_C_G","num_shortPoly_ins_C_G","num_midSizePoly_ins_C_G", "num_longPoly_ins_C_G",
                      "perc_noPoly_del_A_T","perc_shortPoly_del_A_T","perc_midSizePoly_del_A_T", "perc_longPoly_del_A_T", 
                      "perc_noPoly_del_C_G","perc_shortPoly_del_C_G","perc_midSizePoly_del_C_G", "perc_longPoly_del_C_G",
                      "perc_noPoly_ins_A_T","perc_shortPoly_ins_A_T","perc_midSizePoly_ins_A_T", "perc_longPoly_ins_A_T",
                      "perc_noPoly_ins_C_G","perc_shortPoly_ins_C_G","perc_midSizePoly_ins_C_G", "perc_longPoly_ins_C_G",
                      "num_rec_sims","perc_rec_sims",
                      "num_rec_1bp_del_A_T","num_rec_1bp_del_C_G","num_rec_1bp_ins_A_T","num_rec_1bp_ins_C_G","perc_rec_1bp_del_A_T","perc_rec_1bp_del_C_G","perc_rec_1bp_ins_A_T","perc_rec_1bp_ins_C_G")
    
    sim_stats_sample <- as.data.frame(matrix(data=0, nrow=1, ncol=length(sim_measures)))
    colnames(sim_stats_sample) <- sim_measures
    
    sim_stats_sample[, "num_ins"] <- nrow(sims_df[which(nchar(sims_df$REF) == 1 & nchar(sims_df$ALT) > 1),])
    sim_stats_sample[, "num_del"] <- nrow(sims_df[which(nchar(sims_df$REF) > 1 & nchar(sims_df$ALT) == 1),])
    sim_stats_sample[, "num_del_ins"] <- nrow(sims_df[which(nchar(sims_df$REF) > 1 & nchar(sims_df$ALT) > 1),])
    
    print("start getStatsSIMs")
    
    # get total number of SIMs
    num_sims<- nrow(sims_df)
    
    sim_stats_sample[,"num_sims"] <- num_sims
    
    # get 1 bp SIMs only
    sim_1bp_calls <- get1bpSIMs(sims_df) 
    
    if(nrow(sim_1bp_calls) > 0)
    {
      # get number of 1 bp SIMs per subtype A/T del., C/G del., A/T ins., C/G ins.
      num_1bp_sims_per_type <- t(as.matrix(table(sim_1bp_calls$sim_sub_type)))
      colnames(num_1bp_sims_per_type) <- paste("num_1bp_", colnames(num_1bp_sims_per_type), sep="")
      
      sim_stats_sample[,colnames(num_1bp_sims_per_type)] <- num_1bp_sims_per_type
      
      # get percentage of 1 bp SIMs per subtype A/T del., C/G del., A/T ins., C/G ins.
      perc_1bp_sims_per_type <- (num_1bp_sims_per_type*100)/nrow(sim_1bp_calls)
      colnames(perc_1bp_sims_per_type) <- sub("num", "perc", colnames(perc_1bp_sims_per_type))
      
      sim_stats_sample[,colnames(perc_1bp_sims_per_type)] <- perc_1bp_sims_per_type
      
      #get the number of 1 bp SIMs per context length
      sim_1bp_context_stats <- getSIMContextStats(sim_1bp_calls,file_fastaGenome)
      
      sim_stats_sample[,colnames(sim_1bp_context_stats)] <- sim_1bp_context_stats
    }
    
    # get statistics of recurrent SIMs
    if(!is.null(recurrent_sims_df)){
      if(nrow(recurrent_sims_df) > 0)
      {
        sim_rec_stats <- getRecStatsSIMs(sim_stats_sample, recurrent_sims_df)
        sim_stats_sample[,colnames(sim_rec_stats)] <- sim_rec_stats
      }
    }
    
    
    print("end getStatsSIMs")
    
    return(sim_stats_sample)
  }
  
  #' get only the 1 bp SIMs, excluding DELINS (deletions followed by an insertion)
  #' @param sims_df: data.frame with the SIMs of the sample
  #' @return data.frame with all 1bp SIMs excluding DELINS
  get1bpSIMs <- function(sims_df)
  {
    print("start get1bpSIMs")
    
    sims_df$ref_length <- nchar(sims_df$REF)
    sims_df$alt_length <- nchar(sims_df$ALT)
    
    del_1bp_calls <- sims_df[which(sims_df$alt_length == 1 & sims_df$ref_length == 2 & !grepl("N", sims_df$REF)),]
    ins_1bp_calls <- sims_df[which(sims_df$alt_length == 2 & sims_df$ref_length == 1 & !grepl("N", sims_df$ALT)),]
    
    ins_1bp_calls$base_sim <- substr(start=2, stop = 2, x= ins_1bp_calls[,"ALT"])
    del_1bp_calls$base_sim <- substr(start=2, stop = 2, x= del_1bp_calls[,"REF"])
    
    if(nrow(ins_1bp_calls) > 0) {
      
      ins_1bp_calls$sim_sub_type <- paste("ins_",ifelse(ins_1bp_calls$base_sim %in% c("A","T"), "A_T", "C_G"),sep="") 
      
    } 
  
    if(nrow(del_1bp_calls)>0) {
      
      del_1bp_calls$sim_sub_type <- paste("del_",ifelse(del_1bp_calls$base_sim %in% c("A","T"), "A_T", "C_G"),sep="") 
    }
    
    sim_1bp_calls <- rbind(del_1bp_calls,ins_1bp_calls)
    
    sim_1bp_calls_noDI <- sim_1bp_calls[which(substr(start=1, stop = 1, x= sim_1bp_calls[,"REF"]) ==  substr(start=1, stop = 1, x= sim_1bp_calls[,"ALT"])),]
    
    print("end get1bpSIMs")
    
    return(sim_1bp_calls_noDI)
  }
  
  #' Compute the statistics for homopolymer context of  bp SIMs
  #' @param sim_1bp_calls: data.frame with all 1 bp SIMs
  #' @param file_fastaGenome: location of the file with the genome sequence (GRCh37/h19)
  #' @return data.frame with the statistics related to the homopolymer context of 1 bp SIMs
  getSIMContextStats <- function(sim_1bp_calls,file_fastaGenome)
  {
    print("start getSIMContextStats")
    
    # add a 10 bp in length sequence context to each 1 bp SIM
    sim_1bp_calls <- addContextSIMs(sim_1bp_calls,file_fastaGenome)
    
    sim_subtypes <- c("del_A_T", "del_C_G","ins_A_T", "ins_C_G")
    
    polymercontext_stats <- do.call(cbind, lapply(1:length(sim_subtypes), function(i)
    {
      
      ####################################################################################################################################
      # Count the number of 1 bp SIMs for each length of homopolymers. Homopolymers longer than 10 bp are added to the counts for 10 bp. #
      ####################################################################################################################################
      if(sim_subtypes[i] %in% c("del_A_T", "del_C_G")){
        cur_polymercontext_stats_counts <- matrix(data=0,nrow=1, ncol=14)
        colnames(cur_polymercontext_stats_counts) <- paste(c("num_polyL_1_","num_polyL_2_","num_polyL_3_","num_polyL_4_","num_polyL_5_","num_polyL_6_","num_polyL_7_","num_polyL_8_","num_polyL_9_","num_polyL_10_","num_noPoly_", "num_shortPoly_", "num_midSizePoly_", "num_longPoly_"), sim_subtypes[i],sep="")
      }
      else{
        cur_polymercontext_stats_counts <- matrix(data=0,nrow=1, ncol=15)
        colnames(cur_polymercontext_stats_counts) <- paste(c("num_polyL_0_", "num_polyL_1_","num_polyL_2_","num_polyL_3_","num_polyL_4_","num_polyL_5_","num_polyL_6_","num_polyL_7_","num_polyL_8_","num_polyL_9_","num_polyL_10_","num_noPoly_", "num_shortPoly_", "num_midSizePoly_", "num_longPoly_"), sim_subtypes[i],sep="")
      }
      
      cur_sim_1bp_calls <- sim_1bp_calls[which(sim_1bp_calls$sim_sub_type == sim_subtypes[i]),]
      
      if(sim_subtypes[i] %in% c("ins_A_T", "ins_C_G"))
      {
        cur_polymercontext_stats_counts[1,paste("num_polyL_0_",  sim_subtypes[i],sep="")] <- nrow(cur_sim_1bp_calls[which(cur_sim_1bp_calls$length_homopolymer == 0),])  
      }
      cur_polymercontext_stats_counts[1,paste("num_polyL_1_",  sim_subtypes[i],sep="")] <- nrow(cur_sim_1bp_calls[which(cur_sim_1bp_calls$length_homopolymer == 1),])
      cur_polymercontext_stats_counts[1,paste("num_polyL_2_",  sim_subtypes[i],sep="")] <- nrow(cur_sim_1bp_calls[which(cur_sim_1bp_calls$length_homopolymer == 2),])
      cur_polymercontext_stats_counts[1,paste("num_polyL_3_",  sim_subtypes[i],sep="")] <- nrow(cur_sim_1bp_calls[which(cur_sim_1bp_calls$length_homopolymer == 3),])
      cur_polymercontext_stats_counts[1,paste("num_polyL_4_",  sim_subtypes[i],sep="")] <- nrow(cur_sim_1bp_calls[which(cur_sim_1bp_calls$length_homopolymer == 4),])
      cur_polymercontext_stats_counts[1,paste("num_polyL_5_",  sim_subtypes[i],sep="")] <- nrow(cur_sim_1bp_calls[which(cur_sim_1bp_calls$length_homopolymer == 5),])
      cur_polymercontext_stats_counts[1,paste("num_polyL_6_",  sim_subtypes[i],sep="")] <- nrow(cur_sim_1bp_calls[which(cur_sim_1bp_calls$length_homopolymer == 6),])
      cur_polymercontext_stats_counts[1,paste("num_polyL_7_",  sim_subtypes[i],sep="")] <- nrow(cur_sim_1bp_calls[which(cur_sim_1bp_calls$length_homopolymer == 7),])
      cur_polymercontext_stats_counts[1,paste("num_polyL_8_",  sim_subtypes[i],sep="")] <- nrow(cur_sim_1bp_calls[which(cur_sim_1bp_calls$length_homopolymer == 8),])
      cur_polymercontext_stats_counts[1,paste("num_polyL_9_",  sim_subtypes[i],sep="")] <- nrow(cur_sim_1bp_calls[which(cur_sim_1bp_calls$length_homopolymer == 9),])
      
      # as we only look 10 bp to the 3' prime end this also include homopolymers longer than 10 bp.
      cur_polymercontext_stats_counts[1,paste("num_polyL_10_",  sim_subtypes[i],sep="")] <- nrow(cur_sim_1bp_calls[which(cur_sim_1bp_calls$length_homopolymer == 10),])
      
      ################################
      # Summarize to four categories #
      ################################
      
      # no homopolymer: 0 bp for deletions, 0 or 1 bp for insertions
      cur_polymercontext_stats_counts[1,paste("num_noPoly_",  sim_subtypes[i],sep="")] <- nrow(cur_sim_1bp_calls[which(cur_sim_1bp_calls$length_homopolymer %in% c(0,1)),])
      
      # homopolymers of 2-4 bp in length
      cur_polymercontext_stats_counts[1,paste("num_shortPoly_",  sim_subtypes[i],sep="")] <- nrow(cur_sim_1bp_calls[which(cur_sim_1bp_calls$length_homopolymer %in% c(2,3,4)),])
      
      # homopolymers of 5-7 bp in length
      cur_polymercontext_stats_counts[1,paste("num_midSizePoly_",  sim_subtypes[i],sep="")] <- nrow(cur_sim_1bp_calls[which(cur_sim_1bp_calls$length_homopolymer %in% c(5,6,7)),])
      
      # homopolymers of >8 bp in length
      cur_polymercontext_stats_counts[1,paste("num_longPoly_",  sim_subtypes[i],sep="")] <- nrow(cur_sim_1bp_calls[which(cur_sim_1bp_calls$length_homopolymer %in% c(8,9,10)),])
      
      ##########################################################################
      # Compute percentage of 1 bp SIMs for each category of hompolymer lenght #
      ##########################################################################
      polySummaryStats_colnames <- paste(c("num_noPoly_","num_shortPoly_","num_midSizePoly_","num_longPoly_"),  sim_subtypes[i],sep="")
      
      if(sum(cur_polymercontext_stats_counts[,polySummaryStats_colnames]) > 0)
      {
        cur_polymercontext_stats_perc <- as.data.frame(t((cur_polymercontext_stats_counts[,polySummaryStats_colnames]*100)/sum(cur_polymercontext_stats_counts[,polySummaryStats_colnames])))
        colnames(cur_polymercontext_stats_perc) <- sub("num", "perc", polySummaryStats_colnames)
        
        cur_polymercontext_stats <- cbind(cur_polymercontext_stats_counts, cur_polymercontext_stats_perc)
        
      } else {
        
        cur_polymercontext_stats <- cur_polymercontext_stats_counts
      }
      
      return(cur_polymercontext_stats)
    }))
    
    print("end getSIMContextStats")
    return(polymercontext_stats)
  }
  
  #' Add a context of 10 bp in 3' direction to the data.frame with 1 bp SIMs
  #' @param sim_1bp_calls: data.frame with the 1bp SIMs
  #' @param file_fastaGenome: location of the file with the genome sequence (GRCh37/h19) 
  #' @return data.frame with the 1bp SIMs and a 10 bp sequence context in 3' direction
  addContextSIMs <- function(sim_1bp_calls,file_fastaGenome)
  {
    print("start addContextSIMs")
    
    genome_fasta <- open(FaFile(file_fastaGenome)) 
    
    chromosomes <- as.character(sim_1bp_calls$CHROM)
    
    coorBases_post <- GRanges(seqnames = chromosomes, ranges=IRanges(start=as.numeric(as.character(sim_1bp_calls$POS))+1, end=as.numeric(as.character(sim_1bp_calls$POS))+10))
    
    sim_1bp_calls$context_10_bases <- as.character(scanFa(genome_fasta, param=coorBases_post))
    
    sim_1bp_calls$length_homopolymer <- unlist(lapply(1:nrow(sim_1bp_calls), function(i)
    {
      n <- 1
      while(startsWith(x=sim_1bp_calls[i,"context_10_bases"],prefix=paste(rep(sim_1bp_calls[i,"base_sim"], times=n),collapse="")))
      {
        n <- n + 1
      }
      
      length_homopolymer <- n-1
      
    }))
    
    genome_fasta <- close(genome_fasta) 
    
    print("end addContextSIMs")
    return(sim_1bp_calls)
  }

  #' Compute the statistics for the recurrent SIMs
  #' @param stats_general: general statistics of the sample
  #' @param recurrent_sims_df: data.frame with the recurrent SIMs of the sample
  #' @return data.frame with the statistics for the recurrent SIMs
  getRecStatsSIMs <- function(stats_general, recurrent_sims_df)
  {
    num_sims <- stats_general$num_sims
    num_1bp_sims_per_type <- stats_general[,c("num_1bp_del_A_T","num_1bp_del_C_G","num_1bp_ins_A_T","num_1bp_ins_C_G")]
    
    sim_rec_measures <- c("num_rec_sims","perc_rec_sims",
                          "num_rec_1bp_del_A_T","num_rec_1bp_del_C_G","num_rec_1bp_ins_A_T","num_rec_1bp_ins_C_G","perc_rec_1bp_del_A_T","perc_rec_1bp_del_C_G","perc_rec_1bp_ins_A_T","perc_rec_1bp_ins_C_G")
    
    sim_rec_stats_sample <- as.data.frame(matrix(data=0, nrow=1, ncol=length(sim_rec_measures)))
    colnames(sim_rec_stats_sample) <- sim_rec_measures
    
    num_rec_sims <- nrow(recurrent_sims_df)
    perc_rec_sims <- (num_rec_sims*100)/num_sims
    
    
    sim_rec_stats_sample[,"num_rec_sims"] <- num_rec_sims
    sim_rec_stats_sample[,"perc_rec_sims"] <- perc_rec_sims
    
    if(num_rec_sims > 0)
    {
      recurrent_sims_df$ref_length <- nchar(recurrent_sims_df$REF)
      recurrent_sims_df$alt_length <- nchar(recurrent_sims_df$ALT)
      
      rec_del_1bp_calls <- recurrent_sims_df[which(recurrent_sims_df$alt_length == 1 & recurrent_sims_df$ref_length == 2 & !grepl("U", recurrent_sims_df$REF)),]
      rec_ins_1bp_calls <- recurrent_sims_df[which(recurrent_sims_df$alt_length == 2 & recurrent_sims_df$ref_length == 1 & !grepl("U", recurrent_sims_df$ALT)),]
      
      rec_ins_1bp_calls$base_sim <- substr(start=2, stop = 2, x= rec_ins_1bp_calls[,"ALT"])
      rec_del_1bp_calls$base_sim <- substr(start=2, stop = 2, x= rec_del_1bp_calls[,"REF"])
      
      if(nrow(rec_ins_1bp_calls) > 0) 
      {
        rec_ins_1bp_calls$sim_sub_type <- paste("ins_",ifelse(rec_ins_1bp_calls$base_sim %in% c("A","T"), "A_T", "C_G"),sep="") 
      } 
      
      if(nrow(rec_del_1bp_calls) > 0) {
        
        rec_del_1bp_calls$sim_sub_type <- paste("del_",ifelse(rec_del_1bp_calls$base_sim %in% c("A","T"), "A_T", "C_G"),sep="") 
      }
      
      rec_sim_1bp_calls <- rbind(rec_del_1bp_calls,rec_ins_1bp_calls)
      
      rec_sim_1bp_calls_noDI <- rec_sim_1bp_calls[which(substr(start=1, stop = 1, x= rec_sim_1bp_calls[,"REF"]) ==  substr(start=1, stop = 1, x= rec_sim_1bp_calls[,"ALT"])),]
      
      if(nrow(rec_sim_1bp_calls_noDI) > 0) {
        num_rec_1bp_sims_per_type <- t(as.matrix(table(rec_sim_1bp_calls_noDI$sim_sub_type)))
        colnames(num_rec_1bp_sims_per_type) <- paste("num_rec_1bp_", colnames(num_rec_1bp_sims_per_type), sep="")
        
        perc_rec_1bp_sims_per_type <- (num_rec_1bp_sims_per_type*100)/num_1bp_sims_per_type[,sub(pattern = "rec_", replacement = "",x = colnames(num_rec_1bp_sims_per_type))]
        colnames(perc_rec_1bp_sims_per_type) <- sub("num", "perc", colnames(num_rec_1bp_sims_per_type))
        
        sim_rec_stats_sample[,colnames(num_rec_1bp_sims_per_type)] <- num_rec_1bp_sims_per_type
        sim_rec_stats_sample[,colnames(perc_rec_1bp_sims_per_type)] <- perc_rec_1bp_sims_per_type
      }
      
    }
    
    return(sim_rec_stats_sample)
  }


#### 
# Step 2+3+4: scale features, PCA, select first n components explaining the indicated percentage of variance.
######

#' Run PCA on the features to get the variance explained, determine the number of PCs to explain 'min_explained_var' and rerun PCA with this number of PCs to return.  
#' Note: sample IDs should be used as row names and metadata like tumor type should be left out
#' @param features: data.frame with the 42 features
#' @param min_explained_var: threshold for the minimum variance to be explained by the PCs for subsetting
#' @return PCA object with the subset of PCs
getPCA <- function(features, min_explained_var)
{
  res_pca <- PCA(features, scale.unit = TRUE, graph=FALSE)
  
  # get the number of PCs explaining at least the 'min_explained_var' of the variance
  # check if any eigenvalue is exactly 'min_explained_var'
  if(any(res_pca$eig[,"cumulative percentage of variance"]  == min_explained_var))
    num_pc_minExplvar <- which(res_pca$eig[,"cumulative percentage of variance"]  == min_explained_var)
  else{
    num_eigval_belowTH <- length(res_pca$eig[which(res_pca$eig[,"cumulative percentage of variance"] < min_explained_var),"cumulative percentage of variance"])
    num_pc_minExplvar <- num_eigval_belowTH + 1
  }
  
  res_pca_subsetPCs <- PCA(features, scale.unit = TRUE, ncp = num_pc_minExplvar, graph=FALSE)
  
  return(res_pca_subsetPCs)
}

##################################################################################
# Step 5+6: HCPC including consolidation step (k-means clustering: consol=TRUE)  #
##################################################################################

#' Run HCPC
#' Cut the hierarchical tree at 'num_clusters'.
#' @param res_pca: PCA obejct with the subset of PCs
#' @param num_clusters: threshold for the hierarchical clustering - number of clusters 
#' @return HCPC object
getHCPC <- function(res_pca, num_clusters)
{
    set.seed(10)
    res_hcpc <- HCPC(res_pca, nb.clust=num_clusters, graph = FALSE,consol=TRUE)
    
    return(res_hcpc)
}

#################################################
# Step 7: Summarise annotation at cluster level #
#################################################

source("main_mutationLevelAnn.R")
source("main_sampleLevelAnn.R")

#' Annotate the samples with metadata to be used to make the plots on cluster level
#' Required identifiers to link metadata: icgc_donor_id, submitted_donor_id, tumor_wgs_icgc_specimen_id, tumor_wgs_aliquot_id, tcga_donor_uuid, tumor_wgs_submitter_sample_id
#' @param res_hcpc: HCPC object with the clustering result
#' @param sample2ttype: samples linked to the tumour type
#' @param sample_info_file: file with the mapping between the sample ID, the original VCF file with SSMs, the original VCF file with SIMs, the VCF file with recurrent SSMs and the VCF file with the recurrent SIMs 
#' @param vcfIsFiltered: boolean to indicate whether or not the VCF file has been filtered based on the FILTER column
#' @param filename_drivers: location of file with predicted driver mutations. To link to PCAWG: tumor_wgs_aliquot_id <--> sample_id, https://www.biorxiv.org/content/10.1101/190330v2
#' @param filename_IGHV_status: location of file with IGHV data. To link to PCAWG: submitted_donor_id <--> Case,  https://www.nature.com/articles/nature14666
#' @param filename_MSI_classification_1: MSI status according to MSI-Method 1. To link to PCAWG: tumor_wgs_submitter_sample_id <--> ID, https://docs.icgc.org/pcawg/data/
#' @param filename_MSI_classification_2: MSI status according to MSI-Method 2. To link to PCAWG:tumor_wgs_aliquot_id <--> tumor_wgs_aliquot_id, https://www.biorxiv.org/content/10.1101/208330v1
#' @param filenames_replication_time: list of filenames with replication time data (one file per cell line)
#' @param filename_SBS_signatures: SBS Signature data. To link to PCAWG: tumor_wgs_icgc_specimen_id <--> icgc_specimen_id,  https://www.biorxiv.org/content/10.1101/322859v2
#' @param filename_DBS_signatures: DBS Signature data. To link to PCAWG: tumor_wgs_icgc_specimen_id <--> icgc_specimen_id,  https://www.biorxiv.org/content/10.1101/322859v2
#' @param filename_ID_signatures: ID Signature data. To link to PCAWG: tumor_wgs_icgc_specimen_id <--> icgc_specimen_id,  https://www.biorxiv.org/content/10.1101/322859v2
#' @param filename_pcawg_smoking_status: smoking status from PCAWG. Annotation PCAWG uses the icgc_donor_id, https://docs.icgc.org/pcawg/data/
#' @param metadataDir: directory where the metadata is stored
#' @param annSamplesDir: directory where to store the the sample files annotated on mutation level 
#' @param annSamplesFolder_ssms: folder to store the sample files annotated on mutation level for SSMs
#' @param annSamplesFolder_sims: folder to store the sample files annotated on mutation level for SIMs
#' @param num_cores: number of cores to be used in mclapply              
annotateClusters <- function(res_hcpc, sample2ttype, sample_info_file, vcfIsFiltered, filename_drivers, filename_IGHV_status, filename_MSI_classification_1, filename_MSI_classification_2, filenames_replication_time, filename_SBS_signatures, filename_DBS_signatures, filename_ID_signatures, filename_pcawg_smoking_status,  metadataDir, annSamplesDir, annSamplesFolder_ssms, annSamplesFolder_sims, num_cores)
{  
  sample_info <- read.table(file = sample_info_file, header=TRUE, sep = "\t", stringsAsFactors = FALSE)
  
  #clustering results
  res_hcpc$data.clust$sample_id <- rownames(res_hcpc$data.clust)
  
  sample2ttype_cluster <- merge(sample2ttype, res_hcpc$data.clust[,c("sample_id", "clust")], by="sample_id")
  sample2ttype_cluster$cluster <- sample2ttype_cluster$clust
  sample2ttype_cluster$cluster <- revalue(sample2ttype_cluster$cluster, c("1"="C", "2"="A", "3"="B", "4"="D", "5"="G", "6"="E", "7"="F", "8"="I", "9"="K", "10"="O", "11"="L", "12"="M", "13"="H", "14"="N", "15"="P", "16"="J"))
  
  sample2ttype_cluster <- sample2ttype_cluster[,c("sample_id", "tumor_type", "cluster")]
  
  # Data downloaded from: https://www.gencodegenes.org/human/releases.html
  gencode_annotation_v19 <- import(paste(metadataDir, "/gencode.v19.annotation.gtf.gz", sep=""))
  
  # Data downloaded from: http://genome.ucsc.edu/cgi-bin/hgFileUi?db=hg19&g=wgEncodeUwRepliSeq - wavelet smoothed signal
  replicationTimeScores <- readInBigWigFile(file_names_replication_time, metadataDir)

  # annotate SSMs with functional category and replication time (impact classification is already available in VCF file)
  annotateAtMutationLevel(sample_info, vcfIsFiltered, "ssm", gencode_annotation_v19, replicationTimeScores, annSamplesDir, annSamplesFolder_ssms, num_cores)
  
  # annotate SIMs with functional category and replication time (impact classification is already available in VCF file)
  annotateAtMutationLevel(sample_info, vcfIsFiltered, "sim", gencode_annotation_v19, replicationTimeScores, annSamplesDir,  annSamplesFolder_sims, num_cores)
  
  replicationTimeScores_df <- as.data.frame(replicationTimeScores)
  
  #Summarize to sample level: functional category, replication time, impact classification
  #Add IGHV status, tobacco status, drivers, signatures, MSI
  sample2annotation2cluster <- annotateAtSampleLevel(sample2ttype_cluster, gencode_annotation_v19, replicationTimeScores_df, metadataDir, filename_drivers, filename_IGHV_status, filename_MSI_classification_1, filename_MSI_classification_2, filename_SBS_signatures, filename_DBS_signatures, filename_ID_signatures, filename_pcawg_smoking_status, annSamplesDir, annSamplesFolder_ssms, annSamplesFolder_sims, num_cores)
  
  return(sample2annotation2cluster)
}